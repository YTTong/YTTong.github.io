<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if('123456'){
            if (prompt('请输入文章密码') !== '123456'){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ByteDance,">










<meta name="description" content="A young idler, an old beggar.     字节跳动—面试总结">
<meta name="keywords" content="ByteDance">
<meta property="og:type" content="article">
<meta property="og:title" content="字节跳动面经">
<meta property="og:url" content="http://ytsjh.top/2019/07/18/字节跳动面经/index.html">
<meta property="og:site_name" content="Tong&#39;s Blog">
<meta property="og:description" content="A young idler, an old beggar.     字节跳动—面试总结">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://ytsjh.top/myimages/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8.jpg">
<meta property="og:image" content="http://ytsjh.top/myimages/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0.png">
<meta property="og:updated_time" content="2019-07-18T09:25:12.701Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="字节跳动面经">
<meta name="twitter:description" content="A young idler, an old beggar.     字节跳动—面试总结">
<meta name="twitter:image" content="http://ytsjh.top/myimages/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ytsjh.top/2019/07/18/字节跳动面经/">





  <title>字节跳动面经 | Tong's Blog</title>
  








  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
	<a href="https://github.com/YTTong" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Less is more.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ytsjh.top/2019/07/18/字节跳动面经/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="殷彤">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/yt.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">字节跳动面经</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-18T17:13:06+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote class="blockquote-center"> A young idler, an old beggar. </blockquote> 

<p><img src="/myimages/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8.jpg" alt></p>
<p>字节跳动—面试总结</p>
<a id="more"></a>

<p><strong>下面是我的面经，特别惨烈，主要还是自己学的太菜了…</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">自我介绍</span><br><span class="line"></span><br><span class="line">因为简历上的项目用到了socket，解释一下工作过程</span><br><span class="line"></span><br><span class="line">事务的特性：原子性，隔离性，一致性，持续性</span><br><span class="line"></span><br><span class="line">数据库用的多不多，mysql用到什么程度</span><br><span class="line"></span><br><span class="line">手撕代码：topK问题，给定一批数，如n个， 然后从中找出k个最大（小）的数。 </span><br><span class="line"></span><br><span class="line">过程中问到快排（自己给自己挖的坑，快排没讲清楚），算法复杂度，怎么降低算法复杂度</span><br></pre></td></tr></table></figure>

<p><strong>以下是同学面试的总结以及在牛客网看到的。</strong></p>
<h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事务：是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）；</span><br><span class="line"></span><br><span class="line">事务的四大特性：</span><br><span class="line">-原子性 </span><br><span class="line">事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 </span><br><span class="line">-一致性 </span><br><span class="line">事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 </span><br><span class="line">-隔离性 </span><br><span class="line">一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 </span><br><span class="line">-持续性 </span><br><span class="line">也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</span><br></pre></td></tr></table></figure>

<h3 id="tcp流量控制（针对点对点通信量的控制，是个端对端的问题）"><a href="#tcp流量控制（针对点对点通信量的控制，是个端对端的问题）" class="headerlink" title="tcp流量控制（针对点对点通信量的控制，是个端对端的问题）"></a>tcp流量控制（针对点对点通信量的控制，是个端对端的问题）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。</span><br><span class="line">流量控制：让发送方发送速率不要太快，要让接收方来得及接收。（一直）</span><br><span class="line">发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)。</span><br><span class="line">可以把窗口理解为缓冲区（但是有些窗口和缓冲区又不太一样）。如果没有这些“窗口”，那么TCP没发送一段数据后都必须等到接收端确认后才能发送下一段数据，这样做的话TCP传输的效率实在是太低了。解决的办法就是在发送端等待确认的时候继续发送数据。这就是窗口（缓冲区）引入的缘由。</span><br></pre></td></tr></table></figure>

<h3 id="tcp拥塞控制"><a href="#tcp拥塞控制" class="headerlink" title="tcp拥塞控制"></a>tcp拥塞控制</h3><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要作的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.慢开始（慢启动)</span><br><span class="line">（1）在主机刚刚开始发送报文段时可先将拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。</span><br><span class="line">（2）在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。</span><br><span class="line">（3）用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">慢开始门限的用法：</span><br><span class="line">当cwnd&lt;ssthresh，使用慢开始方法</span><br><span class="line">当cwnd&gt;ssthresh,使用拥塞避免</span><br><span class="line">当cwnd=ssthresh，两种都可以使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.拥塞避免---cwnd加1增长</span><br><span class="line">思想：让拥塞窗口cwnd缓慢的增大，即每经过一个往返时间RTT，就把发送方的拥塞窗口+1，让拥塞串口cwnd按照线性规律缓慢增长</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.快重传</span><br><span class="line">发送端只要一连收到三个重复的ACK就应立即重传丢失的报文段而不必继续等待为重传计时器的超时</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.快恢复</span><br><span class="line">发送方连续收到三个重复确认后，就执行“乘法减小”算法，把慢开始门限减半。</span><br><span class="line">发送方认为网络没有发生拥塞，把cwnd的值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大</span><br></pre></td></tr></table></figure>

<h3 id="TCP拥塞控制中的乘法减小（积式减少）和加法增大（和式增加）的意思？"><a href="#TCP拥塞控制中的乘法减小（积式减少）和加法增大（和式增加）的意思？" class="headerlink" title="TCP拥塞控制中的乘法减小（积式减少）和加法增大（和式增加）的意思？"></a>TCP拥塞控制中的乘法减小（积式减少）和加法增大（和式增加）的意思？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.乘法减小：无论是在慢开始阶段还是在拥塞避免阶段，只要出现超时，就要把慢开始门限ssthresh减半。当网络频繁拥塞时，ssthresh就下降得很快，可以迅速减少主机发送到网络中的分组数。</span><br><span class="line">2.加法增大：执行拥塞避免算法后，使得拥塞窗口缓慢增大，以防止网络过早出现拥塞。</span><br></pre></td></tr></table></figure>

<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，线程有自己的堆栈和局部变量。一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但进程切换时耗费资源较大，因此效率较差。</span><br><span class="line">- 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.线程不能够独立执行，必须依存在应用程序中，</span><br><span class="line">- 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</span><br><span class="line">- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。</span><br></pre></td></tr></table></figure>

<h3 id="进程池-线程池-如何设置最大线程数"><a href="#进程池-线程池-如何设置最大线程数" class="headerlink" title="进程池 线程池 如何设置最大线程数"></a>进程池 线程池 如何设置最大线程数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</span><br><span class="line">2.最大线程数与CPU内核相关</span><br><span class="line">CPU密集型：操作内存处理的业务。一般线程数设置为：CPU核数+1或CPU核数*2</span><br><span class="line">IO密集型：文件操作、网络操作、数据库操作。一般线程设置为CPU核数/（1-0.9）</span><br><span class="line">N核服务器，通过执行业务的单线程分析出本地计算时间为x，等待时间为y，则工作线程数（线程池线程数）设置为 N*(x+y)/x，能让CPU的利用率最大化。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程： 相当于生产者，只管向线程池提交任务。并不关心线程池是如何执行任务的。因此，并不关心是哪一个线程执行的这个任务。</span><br><span class="line"></span><br><span class="line">线程池： 相当于消费者，负责接收任务，并将任务分配到一个空闲的线程中去执行。</span><br></pre></td></tr></table></figure>

<p><img src="/myimages/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt></p>
<h3 id="死锁的条件与解决办法"><a href="#死锁的条件与解决办法" class="headerlink" title="死锁的条件与解决办法"></a>死锁的条件与解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">多线程 ：即就是一个程序中有多个线程在同时执行</span><br><span class="line">死锁：两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。</span><br><span class="line">死锁产生的4个必要条件</span><br><span class="line">1、互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。 </span><br><span class="line">2、占有且等待：一个进程本身占有资源（一种或多种），同时还再请求其他资源，而该资源已被其他进程占用，此时请求阻塞，但又对自己获得的其他资源不释放。</span><br><span class="line">3、不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。</span><br><span class="line">4、循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。</span><br><span class="line">  当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。那么，解决死锁问题就是相当有必要的了由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以，主要是破坏产生死锁的其他三个条件</span><br><span class="line">1、破坏“占有且等待”条件</span><br><span class="line">方法1：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。</span><br><span class="line">   优点：简单易实施且安全。</span><br><span class="line">   缺点：因为某项资源不满足，进程无法启动，而其他已经满足了的资源也不会得到利用，严重降低资源的利用率，造成资源浪费。</span><br><span class="line">方法2：对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。</span><br><span class="line">2、破坏“不可抢占”条件</span><br><span class="line">     当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。</span><br><span class="line">      这种方法实现起来比较复杂，代价也比较大。释放已经保持的资源很有可能会导致之前的工作失效，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。</span><br><span class="line">3、破坏“循环等待”条件</span><br><span class="line">     可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源</span><br></pre></td></tr></table></figure>

<h3 id="虚拟内存的实现-lru-（离散型-多次性-对唤性-和虚拟性）"><a href="#虚拟内存的实现-lru-（离散型-多次性-对唤性-和虚拟性）" class="headerlink" title="虚拟内存的实现 lru （离散型 多次性 对唤性 和虚拟性）"></a>虚拟内存的实现 lru （离散型 多次性 对唤性 和虚拟性）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">依赖哈希链表的有序性，把key-value按照最后的使用时间按来排序。</span><br><span class="line">代码见：https://zhuanlan.zhihu.com/p/52196637</span><br><span class="line">使用缓存数据库Redis来实现</span><br></pre></td></tr></table></figure>

<h3 id="内存泄漏与内存溢出"><a href="#内存泄漏与内存溢出" class="headerlink" title="内存泄漏与内存溢出"></a>内存泄漏与内存溢出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露</span><br></pre></td></tr></table></figure>

<h3 id="列举一下，在JAVA虚拟机中，哪些对象可作为GC-ROOTs对象？"><a href="#列举一下，在JAVA虚拟机中，哪些对象可作为GC-ROOTs对象？" class="headerlink" title="列举一下，在JAVA虚拟机中，哪些对象可作为GC ROOTs对象？"></a>列举一下，在JAVA虚拟机中，哪些对象可作为GC ROOTs对象？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">虚拟机栈中的引用对象</span><br><span class="line">方法区中类静态属性引用的对象</span><br><span class="line">方法区中常量引用对象</span><br><span class="line">本地方法栈中JNI引用对象</span><br></pre></td></tr></table></figure>

<h3 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-静态链接和动态链接两者最大的区别就在于链接的时机不一样，静态链接是在形成可执行程序前，而动态链接的进行则是在程序执行时。</span><br><span class="line">-由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。</span><br><span class="line">-动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</span><br></pre></td></tr></table></figure>

<h3 id="请你解释为什么重写equals还要重写hashcode？"><a href="#请你解释为什么重写equals还要重写hashcode？" class="headerlink" title="请你解释为什么重写equals还要重写hashcode？"></a>请你解释为什么重写equals还要重写hashcode？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals()。</span><br><span class="line">如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为</span><br><span class="line">同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。</span><br><span class="line">重载hashCode()是为了对同一个key，能得到相同的HashCode，这样HashMap就可以定位到我们指定的key上。重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。</span><br><span class="line">另外：Java对象的eqauls方法和hashCode方法是这样规定的：</span><br><span class="line">        ➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。</span><br><span class="line">        ➁如果两个对象的hashCode相同，它们并不一定相同。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">现在有两个Student对象：</span><br><span class="line"></span><br><span class="line">    Student s1=new Student(&quot;小明&quot;,18);</span><br><span class="line">    Student s2=new Student(&quot;小明&quot;,18);</span><br><span class="line"></span><br><span class="line">此时s1.equals(s2)一定返回true</span><br><span class="line">假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。</span><br><span class="line"></span><br><span class="line">然而重写了equals，且s1.equals(s2)返回true，根据hashcode的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。</span><br><span class="line"></span><br><span class="line">以下是关于hashcode的一些规定：</span><br><span class="line"></span><br><span class="line">两个对象相等，hashcode一定相等</span><br><span class="line">两个对象不等，hashcode不一定不等</span><br><span class="line">hashcode相等，两个对象不一定相等</span><br><span class="line">hashcode不等，两个对象一定不等</span><br></pre></td></tr></table></figure>

<h3 id="3次握手-4次挥手-2次握手会出现什么情况"><a href="#3次握手-4次挥手-2次握手会出现什么情况" class="headerlink" title="3次握手 4次挥手 2次握手会出现什么情况"></a>3次握手 4次挥手 2次握手会出现什么情况</h3><p>三次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-主机A向主机B发送TCP连接请求数据包，其中包含主机A的初始序列号seq(A)=x。（其中报文中同步标志位SYN=1，ACK=0；序号seq=x，表明传输数据时的第一个数据字节的序号是x）；</span><br><span class="line">-主机B收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含主机B的初始序列号seq(B)=y，以及B对A初始序列号的确认号ack(B)=x+1）</span><br><span class="line">-第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；</span><br></pre></td></tr></table></figure>

<p>四次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下： </span><br><span class="line">-首先客户端A发送一个FIN，用来关闭客户到服务器B的数据传送，然后等待服务器B的确认。其中终止标志位FIN=1，序列号seq=u。 </span><br><span class="line">-服务器B收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。 </span><br><span class="line">-关闭服务器B到客户端A的连接：也是发送一个FIN给客户端A。 </span><br><span class="line">-客户端A收到FIN后，并发回一个ACK报文确认。然后经过2MSL后断开连接。</span><br><span class="line">MSL，最大报文段生存时间。用来处理可能丢失的最后一次的ACK确认。</span><br></pre></td></tr></table></figure>

<h3 id="HTTP流程"><a href="#HTTP流程" class="headerlink" title="HTTP流程"></a>HTTP流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.DNS解析 2.TCP连接 3.发送HTTP请求 4.服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面</span><br></pre></td></tr></table></figure>

<h3 id="请简述一下GC算法"><a href="#请简述一下GC算法" class="headerlink" title="请简述一下GC算法"></a>请简述一下GC算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GC（GarbageCollection 垃圾收集），GC的对象是堆空间和永久区</span><br><span class="line">GC算法包含：标记清除，标记整理，复制算法，分代收集。</span><br><span class="line">判断对象已死吗？</span><br><span class="line">1.引用计数算法：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。</span><br><span class="line">主流的java虚拟机没有采用引用计数算法，其中最主要的原因就是它很难解决对象之间互相循环引用的问题。</span><br><span class="line">2.可达性分析算法</span><br><span class="line">通过一系列的被称为“gc roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“gc roots”没有任何引用链相连时，则证明此对象是不可用的。</span><br><span class="line">3.垃圾回收算法</span><br><span class="line">A.标记-清除算法:分为两个阶段：标记阶段和清除阶段。</span><br><span class="line">实现方案1：在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。</span><br><span class="line">实现方案2：首先标记处所需要回收的对象，在标记完成后统一回收被标记的对象。</span><br><span class="line">缺点：效率不高；标记清楚之后会产生大量不连续的内存碎片，当需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</span><br><span class="line">B.复制算法：将内存按照容量分为大小相同的两块，每次只使用其中一块，当其中以一块内存已满时，将还存活对象复制到另一块内存中，然后再把已使用过的内存空间一次清理掉。（适合回收新生代）</span><br><span class="line">C.标记-整理算法：与标记清除类似，只是在清清除的时候让所有顿获得对象都像一端来进行移动，然后直接清理掉端边界以外的内存。</span><br><span class="line">D.分代收集算法：根据对象存活周期的不同将JAVA堆分成新生代和老年代，根据各个年代的特点选用不同的收集算法。例如：新生代回收时大部分会死去，那就选用复制算法；老年代存活率高，没有额外空间，就必须使用标记清除或标记整理算法。</span><br></pre></td></tr></table></figure>

<h3 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">首先定义Node：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">反转方法如下：递归</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    Node temp = head.next;</span><br><span class="line">    Node newHead = reverse(head.next);</span><br><span class="line">    temp.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">遍历：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseList</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  Node pre = <span class="keyword">null</span>;</span><br><span class="line">  Node next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">      next = node.next;</span><br><span class="line">      node.next = pre;</span><br><span class="line">      pre = node;</span><br><span class="line">      node = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">通过一趟排序将待排序的记录分割成独立的两部分，其中一部分的关键字均比另一部分的关键字小，则可分别对这两部分继续进行排序。</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	assert(<span class="built_in">array</span>);</span><br><span class="line">	<span class="keyword">if</span>(left &gt;= right)<span class="comment">//表示已经完成一个组</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> index = PartSort(<span class="built_in">array</span>,left,right);<span class="comment">//枢轴的位置</span></span><br><span class="line">	QuickSort(<span class="built_in">array</span>,left,index - <span class="number">1</span>);</span><br><span class="line">	QuickSort(<span class="built_in">array</span>,index + <span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序思想"><a href="#堆排序思想" class="headerlink" title="堆排序思想"></a>堆排序思想</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</span><br><span class="line">将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</span><br><span class="line">重新调整结构，使其满足堆定义，继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span><br></pre></td></tr></table></figure>

<h3 id="从输入网址到获得页面的过程（DNS解析-；TCP连接-；发送HTTP请求；服务器处理请求并返回HTTP报文；浏览器解析渲染页面）"><a href="#从输入网址到获得页面的过程（DNS解析-；TCP连接-；发送HTTP请求；服务器处理请求并返回HTTP报文；浏览器解析渲染页面）" class="headerlink" title="从输入网址到获得页面的过程（DNS解析 ；TCP连接 ；发送HTTP请求；服务器处理请求并返回HTTP报文；浏览器解析渲染页面）"></a>从输入网址到获得页面的过程（DNS解析 ；TCP连接 ；发送HTTP请求；服务器处理请求并返回HTTP报文；浏览器解析渲染页面）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查询DNS，获取域名对应的IP地址</span><br><span class="line">1. 浏览器搜索自己的DNS缓存</span><br><span class="line">2. 搜索操作系统的DNS缓存</span><br><span class="line">3. 读取本地的HOST文件（本地ISP域名服务器解析）</span><br><span class="line">4. 发起一个DNS的系统调用（根域名服务器）</span><br><span class="line">	1. 宽带运营服务器查看本身缓存</span><br><span class="line">	2. 运营商服务器发起一个迭代DNS解析请求</span><br><span class="line"></span><br><span class="line">浏览器获得域名对应的IP，通过IP地址找到客户端到服务端的路径。客户端发起HTTP会话到IP地址，然后通过TCP进行封装数据包，传输到网络层（三次握手）。</span><br><span class="line">TCP/IP连接建立起来后，浏览器向服务器发送HTTP请求。</span><br><span class="line">服务器接收到这个请求，根据路径参数，经过后端的处理生成HTML代码返回给浏览器</span><br><span class="line">浏览器拿到完整的HTML页面代码开始解析和渲染</span><br><span class="line">浏览器根据拿到的资源对页面进行渲染，最终得到页面</span><br></pre></td></tr></table></figure>

<h3 id="socket使用"><a href="#socket使用" class="headerlink" title="socket使用"></a>socket使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">维持和硬件通信模块之间的数据交互，通过监听服务器后台指定开放的端口，接收和解析通信模块发送来的数据，并把解析后的数据进行封装入库；利用Listener完成对Socket端口的数据监听，同时使用多线程/线程池创建Socket对象</span><br></pre></td></tr></table></figure>

<h3 id="get-post区别"><a href="#get-post区别" class="headerlink" title="get post区别"></a>get post区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</span><br><span class="line">get将表单中数据按照name=value的形式，添加到URL后面，并且两者使用&quot;?&quot;连接，而各个变量之间使用&quot;&amp;&quot;连接；post是将表单中的数据放在HTTP协议的请求头或消息体中；</span><br><span class="line">get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；</span><br><span class="line">使用get时参数会显示在地址栏上，不安全</span><br></pre></td></tr></table></figure>

<h3 id="单链表找中间节点"><a href="#单链表找中间节点" class="headerlink" title="单链表找中间节点"></a>单链表找中间节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个快指针，一个慢指针。快指针每次走两步，慢指针每次走一步。当快指针走到尾部时，如果链表长度为奇数，慢指针所指的即为中点；如果链表长度为偶数，慢指针指向的下一个结点为中点。</span><br></pre></td></tr></table></figure>

<h3 id="数据库索引什么时候需要建立"><a href="#数据库索引什么时候需要建立" class="headerlink" title="数据库索引什么时候需要建立"></a>数据库索引什么时候需要建立</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在建立表结构时，根据字段的查询频率设置索引，当然如果设置了主键也会建立索引。 在经常需要搜索的列上，可以加快搜索的速度: </span><br><span class="line">在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； </span><br><span class="line">在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； </span><br><span class="line">在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； </span><br><span class="line">在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； </span><br><span class="line">在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</span><br></pre></td></tr></table></figure>

<h3 id="找到共用80端口的线程"><a href="#找到共用80端口的线程" class="headerlink" title="找到共用80端口的线程"></a>找到共用80端口的线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd---&gt; netstat -ano----netstat----&gt; -aon|findstr &quot;49157&quot;或者在任务管理器中查看PID</span><br></pre></td></tr></table></figure>

<h3 id="session与cookie的区别"><a href="#session与cookie的区别" class="headerlink" title="session与cookie的区别"></a>session与cookie的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">区别：1.cookie是应用在客户端，是由web服务器保存在浏览器上的小文件，包含有关用户信息。session是指用来在客户端和服务端之间保持状态的解决方案及存储结构</span><br><span class="line">     2.cookie数据存放在客户端，其他人可以很容易的得到存放在本地的cookie，进行cookie欺骗；session信息存放在服务端，比较安全</span><br><span class="line">     3.session会在一定时间段内保存在服务器上，因此当访问量增加时，会降低服务器性能。cookie性能更高</span><br><span class="line">     4.单个cookie存放的数据布恩那个超过4KB，很多浏览器限制一个站点最多保存20个cookie</span><br></pre></td></tr></table></figure>

<h3 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.黑盒测试又称为功能测试、数据驱动测试，是一种从用户观点出发的测试。测试人员一般把被测程序当作一个黑盒子。</span><br><span class="line">　　黑盒测试主要测到的错误类型有：不正确或遗漏的功能；接口、界面错误；性能错误；数据结构或外部数据访问错误；初始化或终止条件错误等等。</span><br><span class="line">　　常用的黑盒测试方法有：等价类划分法；边界值分析法；因果图法；场景法；正交实验设计法；判定表驱动分析法；错误推测法；功能图分析法。</span><br><span class="line">2.白盒测试也称为结构测试或逻辑驱动测试，是针对被测单元内部是如何进行工作的测试。它根据程序的控制结构设计测试用例，主要用于软件或程序验证，检查程序内部逻辑结构，对所有的逻辑路径进行测试，但即使每条路径都测试过了，仍然有可能存在错误。</span><br><span class="line">　　白盒测试需要遵循的原则有： 1. 保证一个模块中的所有独立路径至少被测试一次2. 所有逻辑值均需要测试真（true）和假（false）两种情况3. 检查程序的内部数据结构，保证其结构的有效性；4. 在上下边界及可操作范围内运行所有循环。</span><br><span class="line">　　白盒测试方法有：</span><br><span class="line">　　· 静态测试&amp;动态测试：静态测试是不用运行程序的测试，包括代码检查、静态结构分析、代码质量度量、文档测试等等，它可以由人工进行，充分发挥人的逻辑思维优势，也可以借助软件工具（Fxcop）自动进行。动态测试则需要执行代码，也是我们用的最多的一种测试，通过运行程序找到问题，包括功能确认与接口测试、覆盖率分析、性能分析、内存分析等。</span><br><span class="line">　　· 单元测试· 代码检查· 同行评审· 技术评审</span><br><span class="line">3. 灰盒测试 (Gray-Box Testing)</span><br><span class="line">　　灰盒测试更像是白盒测试和黑盒测试的混合测试，现阶段对灰盒测试没有更明确的定义，但更多的时候，我们的测试做的就是灰盒测试，即既会做黑盒测试又会做白盒测试。</span><br></pre></td></tr></table></figure>

<h3 id="java多线程的实现-2种-继承与实现"><a href="#java多线程的实现-2种-继承与实现" class="headerlink" title="java多线程的实现 2种 继承与实现"></a>java多线程的实现 2种 继承与实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1)继承Thread类创建线程</span><br><span class="line">Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以启动新线程并执行自己定义的run()方法。</span><br><span class="line">2)实现Runnable接口创建线程</span><br><span class="line">如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口</span><br></pre></td></tr></table></figure>

<h3 id="过滤器与拦截器"><a href="#过滤器与拦截器" class="headerlink" title="过滤器与拦截器"></a>过滤器与拦截器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) 过滤器(Filter)：依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。</span><br><span class="line">使用过滤器是用来做一些过滤操作，获取我们想要的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，然后再传入servlet或者Controller进行业务逻辑操作。</span><br><span class="line">通用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。</span><br><span class="line"></span><br><span class="line">2) 拦截器（Interceptor）：它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。</span><br><span class="line">由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。</span><br></pre></td></tr></table></figure>

<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。 </span><br><span class="line"></span><br><span class="line">总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。</span><br></pre></td></tr></table></figure>

<h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http协议传输的数据都是未加密的，也就是明文的，因此使用http协议传输隐私信息非常不安全。 </span><br><span class="line">https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</span><br></pre></td></tr></table></figure>

<h3 id="http请求头有哪些字段"><a href="#http请求头有哪些字段" class="headerlink" title="http请求头有哪些字段"></a>http请求头有哪些字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Accept：浏览器可接受的MIME类型。</span><br><span class="line">Accept-Charset：浏览器可接受的字符集。 </span><br><span class="line">Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。</span><br><span class="line">Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</span><br><span class="line">Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。 </span><br><span class="line">Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。 </span><br><span class="line">Content-Length：表示请求消息正文的长度。 </span><br><span class="line">Cookie：设置cookie,这是最重要的请求头信息之一 From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</span><br><span class="line">Host：初始URL中的主机和端口。 </span><br><span class="line">If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。 </span><br><span class="line">Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。</span><br><span class="line">Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 </span><br><span class="line">User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。</span><br><span class="line">UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</span><br></pre></td></tr></table></figure>

<h3 id="斐波那锲数列了解么？"><a href="#斐波那锲数列了解么？" class="headerlink" title="斐波那锲数列了解么？"></a>斐波那锲数列了解么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面相邻两项之和，构成后一项</span><br></pre></td></tr></table></figure>

<h3 id="动态规划相比递归来说有什么优点。"><a href="#动态规划相比递归来说有什么优点。" class="headerlink" title="动态规划相比递归来说有什么优点。"></a>动态规划相比递归来说有什么优点。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动态规划算法是递归算法的一种情况，我们所用的图搜索策略中的很多算法都是基于动态规划的。比如说最短路径算法 </span><br><span class="line"></span><br><span class="line">总地来说是不同的算法。但一些递归算法可改写成动态规划。 动态规划是空间换时间的算法。当递归运算的中间结果要反复使用时，动态规划可能将指数速度的算法改进为多项式速度（但相应地，空间代价提高）</span><br></pre></td></tr></table></figure>

<h3 id="算法的时间复杂度，空间复杂度。"><a href="#算法的时间复杂度，空间复杂度。" class="headerlink" title="算法的时间复杂度，空间复杂度。"></a>算法的时间复杂度，空间复杂度。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度指运行时间的需求</span><br><span class="line">空间复杂度指空间需求</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>

      
    </div>
    
    
    
	
    
	
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    殷彤
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://ytsjh.top/2019/07/18/字节跳动面经/" title="字节跳动面经">http://ytsjh.top/2019/07/18/字节跳动面经/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ByteDance/" rel="tag"># ByteDance</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/15/Servlet与JSP/" rel="next" title="Servlet与JSP">
                <i class="fa fa-chevron-left"></i> Servlet与JSP
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/20/阿里盒马面经/" rel="prev" title="阿里盒马面经">
                阿里盒马面经 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTA2MC8yMTU3Nw=="></div>
    </div>

  





        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/yt.jpg" alt="殷彤">
            
              <p class="site-author-name" itemprop="name">殷彤</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/YTTong" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="791383829@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是事务？"><span class="nav-number">1.</span> <span class="nav-text">什么是事务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp流量控制（针对点对点通信量的控制，是个端对端的问题）"><span class="nav-number">2.</span> <span class="nav-text">tcp流量控制（针对点对点通信量的控制，是个端对端的问题）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp拥塞控制"><span class="nav-number">3.</span> <span class="nav-text">tcp拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP拥塞控制中的乘法减小（积式减少）和加法增大（和式增加）的意思？"><span class="nav-number">4.</span> <span class="nav-text">TCP拥塞控制中的乘法减小（积式减少）和加法增大（和式增加）的意思？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程"><span class="nav-number">5.</span> <span class="nav-text">线程与进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程池-线程池-如何设置最大线程数"><span class="nav-number">6.</span> <span class="nav-text">进程池 线程池 如何设置最大线程数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的条件与解决办法"><span class="nav-number">7.</span> <span class="nav-text">死锁的条件与解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存的实现-lru-（离散型-多次性-对唤性-和虚拟性）"><span class="nav-number">8.</span> <span class="nav-text">虚拟内存的实现 lru （离散型 多次性 对唤性 和虚拟性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄漏与内存溢出"><span class="nav-number">9.</span> <span class="nav-text">内存泄漏与内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列举一下，在JAVA虚拟机中，哪些对象可作为GC-ROOTs对象？"><span class="nav-number">10.</span> <span class="nav-text">列举一下，在JAVA虚拟机中，哪些对象可作为GC ROOTs对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态链接与静态链接"><span class="nav-number">11.</span> <span class="nav-text">动态链接与静态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请你解释为什么重写equals还要重写hashcode？"><span class="nav-number">12.</span> <span class="nav-text">请你解释为什么重写equals还要重写hashcode？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3次握手-4次挥手-2次握手会出现什么情况"><span class="nav-number">13.</span> <span class="nav-text">3次握手 4次挥手 2次握手会出现什么情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP流程"><span class="nav-number">14.</span> <span class="nav-text">HTTP流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请简述一下GC算法"><span class="nav-number">15.</span> <span class="nav-text">请简述一下GC算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表反转"><span class="nav-number">16.</span> <span class="nav-text">链表反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">17.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序思想"><span class="nav-number">18.</span> <span class="nav-text">堆排序思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从输入网址到获得页面的过程（DNS解析-；TCP连接-；发送HTTP请求；服务器处理请求并返回HTTP报文；浏览器解析渲染页面）"><span class="nav-number">19.</span> <span class="nav-text">从输入网址到获得页面的过程（DNS解析 ；TCP连接 ；发送HTTP请求；服务器处理请求并返回HTTP报文；浏览器解析渲染页面）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket使用"><span class="nav-number">20.</span> <span class="nav-text">socket使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-post区别"><span class="nav-number">21.</span> <span class="nav-text">get post区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表找中间节点"><span class="nav-number">22.</span> <span class="nav-text">单链表找中间节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库索引什么时候需要建立"><span class="nav-number">23.</span> <span class="nav-text">数据库索引什么时候需要建立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找到共用80端口的线程"><span class="nav-number">24.</span> <span class="nav-text">找到共用80端口的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session与cookie的区别"><span class="nav-number">25.</span> <span class="nav-text">session与cookie的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#黑盒测试与白盒测试"><span class="nav-number">26.</span> <span class="nav-text">黑盒测试与白盒测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java多线程的实现-2种-继承与实现"><span class="nav-number">27.</span> <span class="nav-text">java多线程的实现 2种 继承与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤器与拦截器"><span class="nav-number">28.</span> <span class="nav-text">过滤器与拦截器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#悲观锁和乐观锁"><span class="nav-number">29.</span> <span class="nav-text">悲观锁和乐观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http和https的区别"><span class="nav-number">30.</span> <span class="nav-text">http和https的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http请求头有哪些字段"><span class="nav-number">31.</span> <span class="nav-text">http请求头有哪些字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#斐波那锲数列了解么？"><span class="nav-number">32.</span> <span class="nav-text">斐波那锲数列了解么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划相比递归来说有什么优点。"><span class="nav-number">33.</span> <span class="nav-text">动态规划相比递归来说有什么优点。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法的时间复杂度，空间复杂度。"><span class="nav-number">34.</span> <span class="nav-text">算法的时间复杂度，空间复杂度。</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>

  
</div>

<!--

  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>

-->


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
